import math
from tkinter import *

class CalculatorApp(Tk):
    def __init__(self):
        super().__init__()
        
        # Настройка окна
        self.title("Научный калькулятор")
        self.geometry("350x350") 
        
        # Инициализация калькулятора
        self.calculator = Calculator()
        
        # Создание дисплея
        self.display = Entry(self, font=('Arial', 20))
        self.display.grid(row=0, column=0, columnspan=4)
        
        # Привязываем клавишу Enter к выполнению вычислений
        self.bind('<Return>', lambda event=None: self.on_button_click('='))
        
        # Добавляем кнопки
        buttons = [
            'C', 'Back', '(', ')',
            '7', '8', '9', '/',
            '4', '5', '6', '*',
            '1', '2', '3', '-',
            '0', '.', '=', '+',
            'sin', 'cos', 'tan', 'exp',
            'cot', 'log'
        ]
        
        row_val = 1
        col_val = 0
        for button_text in buttons:
            Button(self, text=button_text, width=5, height=2,
                   command=lambda t=button_text: self.on_button_click(t)).grid(row=row_val, column=col_val)
            
            col_val += 1
            if col_val > 3:
                col_val = 0
                row_val += 1
    
    def on_button_click(self, key):
        try:
            if key == 'Back':  # Удаляем последний символ
                current_display = self.display.get()
                new_value = current_display[:-1]
                self.display.delete(0, END)
                self.display.insert(END, new_value)
            else:
                result = self.calculator.process_input(key)
                self.display.delete(0, END)
                self.display.insert(END, str(result))
        except Exception as e:
            self.display.delete(0, END)
            self.display.insert(END, f'Ошибка: {e}')

class Calculator:
    def __init__(self):
        self.current_value = ''  # Текущая введённая строка
        self.expecting_argument = False  
    
    def process_input(self, key):
        if key == '=':
            return self.calculate_expression()
        elif key == 'C':
            self.current_value = ''
            self.expecting_argument = False
        elif key in ['sin', 'cos', 'tan', 'exp', 'cot', 'log']:  # Нажата кнопка функции
            # Ставим скобку автоматически
            self.current_value += key + '('
            self.expecting_argument = True  # Ждем аргумент
        else:
            self.current_value += key
        
        return self.current_value
    
    def calculate_expression(self):
        try:
            # Специальные функции с дополнительной обработкой
            special_funcs = {
                'sin(': lambda x: math.sin(float(x)),
                'cos(': lambda x: math.cos(float(x)),
                'tan(': lambda x: math.tan(float(x)),
                'exp(': lambda x: math.exp(float(x)),
                'cot(': lambda x: 1 / math.tan(float(x)),
                'log(': lambda x: math.log(float(x))
            }
            
            for func_str, func in special_funcs.items():
                if func_str in self.current_value:
                    start_idx = self.current_value.find(func_str)
                    end_idx = self.current_value.find(')')
                    
                    # Получаем аргумент функции
                    argument = self.current_value[start_idx + len(func_str):end_idx]
                    result = func(argument.strip())
                    return round(result, 4)
            
            # Обычные арифметические операции
            return round(eval(self.current_value), 4)
        except Exception as e:
            return f'Ошибка: {e}'

if __name__ == "__main__":
    app = CalculatorApp()
    app.mainloop()
